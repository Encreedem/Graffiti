-- TODO: The Progress Bars movePos and scalePos get messed up when it's facing up.

local version = "1.6"

-- >>> Variables

-- Tables for users:
local userFunctions = {}
local userLists = {}
local userInputs = {}
local selectedItems = {}
local selectedFiles = {}

--Monitor
local monitor = nil

-- Text
local text = {}
text.back = " < "
text.quit = " X "
text.refresh = "Refresh"
text.done = "Done"
text.options = "Options"
text.fileSelector = "[...]"

-- Colors
local objectColors = {}
local colorTheme = "Default"

-- Color Themes
local colorThemes = {}
colorThemes.Default = {
  background = colors.black;
  text = colors.white;
  Button = { default = colors.red; active = colors.lime; text = colors.white };
  ProgressBar = { low = colors.red; medium = colors.yellow; high = colors.lime; background = colors.gray; };
  Input = { default = colors.white; text = colors.black; active = colors.yellow; };
  List = { default = colors.blue; active = colors.lightBlue; };
  FileSelector = { default = colors.red; text = colors.white; dir = colors.lime; file = colors.white; active = colors.lime; };
  Editor = {
    new = colors.white;
    active = colors.lime;
    move = colors.magenta;
    scale = colors.pink;
    marker = colors.gray;
    alignmentTrue = colors.lime;
    alignmentFalse = colors.red;
  };
  Container = {
    Panel = {
      border = colors.white;
    };
  };
}

colorThemes["Windows CC"] = {
  background = colors.white;
  text = colors.black;
  Button = { default = colors.lightGray; active = colors.lightBlue; text = colors.black };
  ProgressBar = { low = colors.lime; medium = colors.lime; high = colors.lime; background = colors.lightGray; };
  Input = { default = colors.lightGray; text = colors.black; active = colors.white; };
  List = { default = colors.lightGray; active = colors.lightBlue; };
  FileSelector = { default = colors.gray; text = colors.black; dir = colors.blue; file = colors.black; active = colors.lightBlue; };
  Editor = {
    new = colors.lightBlue;
    active = colors.black;
    move = colors.magenta;
    scale = colors.pink;
    marker = colors.gray;
    alignmentTrue = colors.lime;
    alignmentFalse = colors.red;
  };
  Container = {
    Panel = {
      border = colors.lightGray;
    };
  };
}

for key, value in pairs(colorThemes[colorTheme]) do
  objectColors[key] = value
end

-- Sizes
local size = {}
size.Button = { width = 10; height = 3; }
size.ProgressBar = { length = 10; }
size.Container = { width = 20; height = 10; }

-- Save File
local saveFileName = "Graffiti.sav"

-- API
local initDone = false
local isAPI = false -- Determines whether the program has been loaded as an API
local variableValues = {}
local progressBarValues = {}

-- Editor Options
local editMode = false
local showEditorOptions = false
local editActions = { "Design", "Attributes", "Delete" }
local lastWindow = "mainWindow"
local editorFunctions = {}
local rightClickActions = {"Attributes", "Delete" }

-- tables
local args = { ... }
local sides = { "left", "top", "right", "bottom", "front", "back" }
local objectTypes = { "Button", "Text", "Variable", "ProgressBar", "Input", "List", "Panel" }
local eventTypes = { "quit", "button_clicked", "button_toggled", "selection_changed", "text_changed" }
local objects = {}
local windows = { children = { mainWindow = { objType = "Window", children = {} } } }
local windowBuffer = nil
local defaultButtons = {}

-- Other
local quit = false
local maxX, maxY = 51, 19
local out = term -- Output: either "term" or the monitor
local outIsTerm = false
local autoLoadObjects = true
local changeButtonColor = true
local currentWindow = "mainWindow"

-- >> User Functions

-- user variables
local randomValue= 50

-- user functions

function userFunctions.test()
  sleep(1)
end

function userFunctions.setRandomValue()
  randomValue = math.random(100)
end

function userFunctions.refresh()
  drawWindow()
end

-- user lists

userLists.testList = {
  "Testitem 1",
  "Testitem 2",
  "Testitem 3"
}

-- Define the value of a variable-object.
function getVariableValue(object)
  assert(object)
  local objID = object.objID
  
  if (objID == "testVariable") then
    return "Variable";
  elseif (objID == "Time") then
    return textutils.formatTime(os.time(), true)
  else
    return variableValues[objID]
  end
end

-- Definie the value of a progressBar-object
-- 0: empty; 100: full
function getProgressBarValue(object)
  assert(object)
  local objID = object.objID
  
  if (objID == "testProgressBar") then
    return 87
  elseif (objID == "randomProgressBar") then
    return randomValue
  else
    return progressBarValues[objID]
  end
end

--[[ WARNING!
Everything below this comment
shouldn't be edited!
If you do so and the program doesn't work anymore
then it's your fault!
]]

--[[ Displays the text, the content of a table
or a star in the upper left corner until you press
a key.]]
function dBug(text)
  out.setCursorPos(1, 1)
  
  if (text == nil) then
    out.write("*")
    getKeyInput()
    out.setCursorPos(1, 1)
    out.write(" ")
    return
  elseif (type(text) == "table") then
    for key, value in pairs(text) do
      print(key .. ": " .. tostring(value))
    end
  else
    out.write(text)
  end
  
  getKeyInput()
end

-- >>> Shortcut functions (for key inputs)
-- Not yet implemented! WIP!
-- TODO: Fix bug where the key event won't disappear from the queue.

function callShortcut(key)
  --if (key and shortcut[key]) then
  --  shortcut[key]()
  --end
end

shortcut = {}

-- s
shortcut[31] = function()
  out.clear()
  out.setCursorPos(1, 1)
  print("Saving windows...")
  
  saveWindows()
  
  print("Windows saved!")
  print("Press any key to continue...")
end

-- q
shortcut[16] = function()
  quit = true
end

-- >>> Object helper functions

function clearScreen()
  out.setBackgroundColor(objectColors.background)
  out.setTextColor(objectColors.text)
  out.clear()
  out.setCursorPos(1, 1)
end

function initDefaultButtons()
  defaultButtons.quit = {
    text=text.quit,
    left=maxX - string.len(text.quit) + 1,
    top=1,
    right=maxX,
    bottom=1,
    required = function()
      return true
    end
  }
  
  defaultButtons.back = {
    text = text.back,
    left = 1,
    top = 1,
    right = string.len(text.back),
    bottom = 1,
    required = function()
      return getCurrentWindow().showBackButton
    end
  }
  
  defaultButtons.refresh = {
    text = text.refresh,
    left = maxX - string.len(text.refresh) + 1,
    top = maxY,
    right = maxX,
    bottom = maxY,
    required = function()
      return (getCurrentWindow().showRefreshButton or (editMode and not showEdtorOptions))
    end
  }
  
  defaultButtons.options = {
    text = text.options,
    left = 1,
    top = maxY,
    right = string.len(text.options),
    bottom = maxY,
    required=function()
      return (editMode and not showEditorOptions)
    end
  }
end

-- Returns whether the button with the given name
-- has been pressed.
function defaultButtonPressed(name, x, y)
  assert(name)
  assert(x)
  assert(y)
  
  local window = getCurrentWindow()
  
  if (defaultButtons[name]) then
    local button = defaultButtons[name]
    if (x >= button.left and x <= button.right and y >= button.top and y <= button.bottom) then
      return (button.required() or (editMode and not showEditorOptions and currentWindow ~= "mainWindow"))
    end
  else
    return false
  end
end

-- Returns the window object that is currently
-- displayed.
function getCurrentWindow()
  if showEditorOptions then
    return editorWindows.children[currentWindow]
  else
    return windows.children[currentWindow]
  end
end

-- Used by the List and Selector objects to
-- determine how wide the list should be.
function getLongestString(strings)
  if (strings == nil or #strings == 0) then
    return 0
  end
  
  local ret = 0
  
  for key, value in pairs(strings) do
    length = string.len(value)
    if (length > ret) then
      ret = length
    end
  end
  
  return ret
end

-- Checks whether dir is a valid direction-string.
function isValidDirection(dir)
  if (dir ~= nil and
     (dir == "left" or 
      dir == "up" or 
      dir == "right" or 
      dir == "down")) then
    return true
  end
  
  return false
end

--[[ Returns a table containing tables for all
files and directories in the given path:
Returns: fileName, filePath, isDir
]]
function getFileList(path)
  local ret = {}
  local dirList = {}
  local fileList = {}
  
  for file in fs.list(path) do
    if (fs.isDir(file)) then
      table.insert(dirList, dirIndex, file)
      dirIndex = dirIndex + 1
    else
      table.insert(fileList, fileIndex, file)
      fileIndex = fileIndex + 1
    end
  end
  for _, file in ipairs(dirList) do
    table.insert(list, {fileName=file, filePath=fs.combine(path, file), isDir=true})
  end
  for _, file in ipairs(fileList) do
    table.insert(list, {fileName=file, filePath=fs.combine(path, file), isDir=false})
  end
  
  return ret
end

-- Returns "horizontal" or "vertical" depending on
-- the given direction.
function getOrientation(direction)
  local orientation = nil

  if (direction == "left" or direction == "right") then
    orientation = "horizontal"
  elseif (direction == "up" or direction == "down") then
    orientation = "vertical"
  end

  return orientation
end

function eventTypeExists(eventType)
  if (eventType == nil) then
    return true
  end
  
  for _, event in pairs(eventTypes) do
    if (event == eventType) then
      return true
    end
  end
  
  return false
end

-- >>> Path

Path = {}
function Path:getParent()
  return Path.getContainerAt(self, #self - 1)
end

function Path:getContainerAt(nestLevel)
  local container = getCurrentWindow()
  
  for i = 1, nestLevel do
    if (container.children[self[i]] and container.children[self[i]].isContainer) then
      container = container.children[self[i]]
    else
      return nil -- NOTE: was "break" before
    end
  end
  
  return container
end

function Path:getObject()
  local container = Path.getContainerAt(self, #self - 1)
  return container.children[self[#self]]
end

-- Returns the coordinates which are relative to
-- the last container represented by the path.
function Path:getRelativePos(x, y, checkFullPath)
  local container
  local limit = checkFullPath and #self or #self - 1
  
  for i = 1, limit do
    container = Path.getContainerAt(self, i)
    
    if container then
      x, y = objects.Container.getRelativePos(container, x, y)
      --if not (container.children[self[i + 1]] and container.children[self[i + 1]].isContainer) then
      --  break
      --end
    else
      break
    end
  end
  
  return x, y
end

--[[ Generates a table of keys representing the
nesting of the containers that have been clicked.
Returns: e.g. {containeID, subContainerID}]]
Path.getContainerPath = function(x, y)
  local containerPath = {}
  local currentContainer = getCurrentWindow()
  local finished = false
  local nestLevel = 1
  
  while not finished do
    finished = true -- Set to true so that the loop stops when no container is found.
    for objectID, object in pairs(currentContainer.children) do
      if finished and object.isContainer then
        if (objects.Container.contentAreaClicked(object, x, y)) then
          containerPath[nestLevel] = objectID
          currentContainer = currentContainer.children[objectID]
          x, y = objects.Container.getRelativePos(currentContainer, x, y)
          finished = false
        end
      end
    end
    
    nestLevel = nestLevel + 1
  end
  
  return containerPath
end

-- >>> Buffer

Buffer = {
  bufferTable = {};
  width = 0;
  height = 0;
}

function Buffer.newPixel(backCol, textCol, char, path)
  local ret = {}
  ret.background = backCol or objectColors.background
  ret.text = textCol or objectColors.text
  ret.char = (type(char) == "string" and char ~= "") and char or " "
  ret.path = path or nil
  
  return ret;
end

function Buffer:new(object)
  object = object or {}
  setmetatable(object, self)
  self.__index = self
  return object
end

function Buffer:init(width, height, path, backCol, textCol)
  self.width = width or error("Can't initialize buffer because the width didn't get specified!")
  self.height = height or error("Can't initialize buffer because the height didn't get specified!")
  self.bufferTable = {}
  
  for col = 1, width do
    self.bufferTable[col] = {}
    for row = 1, height do
      self.bufferTable[col][row] = self.newPixel(backCol, textCol, " ", path)
    end
  end
end

function Buffer:trim(left, top, right, bottom)
  left = (left < 0) and 0 or left
  top = (top < 0) and 0 or top
  right = (right < 0) and 0 or right
  bottom = (bottom < 0) and 0 or bottom
  
  local width = self.width - left - right
  local height = self.height - top - bottom
  local trimmed = Buffer:new()
  trimmed:init(width, height)
  
  for col = 1, width do
    for row = 1, height do
      trimmed:setPixel(col, row, self.bufferTable[left + col][top + row])
    end
  end
  
  return trimmed
end

function Buffer:draw(x, y)
  x = x or 1
  y = y or 1
  local currentPixel
  
  for col = 0, self.width - 1 do
    for row = 0, self.height - 1 do
      currentPixel = self.bufferTable[col+1][row+1]
      out.setCursorPos(x + col, y + row)
      out.setBackgroundColor(currentPixel.background)
      out.setTextColor(currentPixel.text)
      out.write(currentPixel.char)
    end
  end
end

function Buffer:setBackgroundColor(color)
  for col = 1, width do
    for row = 1, height do
      self.bufferTable[col][row].background = color
    end
  end
end

function Buffer:setTextColor(color)
  for col = 1, width do
    for row = 1, height do
      self.bufferTable[col][row].text = color
    end
  end
end

function Buffer:setPixel(x, y, pixel)
  assert(x)
  assert(y)
  assert(pixel)
  if (x > 0 and x <= self.width and y > 0 and y <= self.height) then
    for key, value in pairs(pixel) do
      if value then
        self.bufferTable[x][y][key] = value
      end
    end
  end
end

function Buffer:addText(x, y, text)
  assert(x)
  assert(y)
  assert(text)
  
  for char in text:gmatch(".") do
    self:setPixel(x, y, { char=char })
    x = x + 1
  end
end

function Buffer:addBuffer(x, y, buffer)
  assert(x)
  assert(y)
  assert(buffer)
  for col = 1, buffer.width do
    for row = 1, buffer.height do
      self:setPixel(x + col - 1, y + row - 1, buffer.bufferTable[col][row])
    end
  end
end

-- >>> Objects

objects = {}
-- Returns a new object with its default attributes
-- depending on the object type.
function objects.new(objectType, x, y)
  local object = {}
  local path = Path.getContainerPath(x, y)
  local relativeX, relativeY = Path.getRelativePos(path, x, y, true)
  
  object.objID = "new" .. objectType
  object.objType = objectType
  object.path = path
  object.x = relativeX
  object.y = relativeY
  object.absoluteX = x
  object.absoluteY = y
  
  local maxWidth = maxX - x
  local maxHeight = maxY - y
  
  if (objects[objectType] and objects[objectType].new) then
    objects[objectType].new(object, maxWidth, maxHeight)
  elseif (objects.Container[objectType]) then
    objects.Container.new(object, maxWidth, maxHeight)
  else
    objects["Unknown"].new(objectType)
  end
  
  return object
end

function objects.create(objType, x, y)
  local object = objects.new(objType, x, y)
  local container = Path.getContainerAt(object.path, #object.path)
  local key = objects.Container.getNextFreeKey(container)
  table.insert(object.path, key)
  table.insert(container.children, key, object)
  
  windowBuffer:addBuffer(x, y, objects.get(object))
  objects.draw(object)
end

-- Returns the buffer of the object.
function objects.get(self, param)
  local objType = self.objType or "Unknown"
  if (self.isContainer) then
    return objects.Container.get(self, param)
  elseif (objects[objType] and objects[objType].get) then
    return objects[objType].get(self, param)
  else
    error("Can't get buffer of object type \"" .. objType .. "\"!")
  end
end

function objects.remove(self)
  local path = self.path
  local objKey = path[#path]
  local container = Path.getContainerAt(self.path, #self.path - 1)
  
  container.children[objKey] = nil
  
  for i = #path - 2, 0, -1 do
    local parentContainer = Path.getContainerAt(self.path, i)
    parentContainer.children[path[i + 1]] = container
    container = parentContainer
  end
  
  windows.children[currentWindow] = container
end

-- Draws the object.
function objects.draw(self, param)
  local objType = self.objType
  
  if (#self.path > 1) then
    local container = getCurrentWindow()
    local x, y = self.absoluteX, self.absoluteY
    objects.Container.drawBuffer(container, objects.get(self, param), self.path, x, y, x, y, 0)
  else
    local buffer = objects.get(self, param)
    buffer:draw(self.x, self.y)
  end
end

-- Returns the resulting event and a "params"-array.
function objects.click(self, x, y)
  local objType = self.objType
  local event, params
  if objects[objType] and objects[objType].click then
    event, params = objects[objType].click(self, x, y)
  elseif (self.isContainer and objects.Container[objType] and objects.Container[objType].click) then
    event, params = objects.Container[objType].click(self, x, y)
  end
  
  return event, params
end

-- Moves the object.
function objects.move(self, addX, addY)
  assert(self)
  
  local objType = self.objType
  
  if (objects[objType] and objects[objType].move) then
    objects[objType].move(self, addX, addY)
  elseif (self.isContainer) then
    self.x = self.x + addX
    self.y = self.y + addY
    objects.Container.move(self, addX, addY)
  else
    self.x = self.x + addX
    self.y = self.y + addY
    self.absoluteX = self.absoluteX + addX
    self.absoluteY = self.absoluteY + addY
  end
end

-- Scales the object.
function objects.scale(self, x, y)
  assert(self)
  local objType = self.objType
  
  if (objects[objType] and objects[objType].scale) then
    objects[objType].scale(self, x, y)
  elseif (self.isContainer and objects.Container[objType].scale) then
    objects.Container[objType].scale(self, x, y)
  else
    local objX, objY = self.x, self.y
    if (x > objX and y >= objY) then
      self.width = x - objX + 1
      self.height = y - objY + 1
    end
  end
end

--[[ Returns the position of the pixel which shows
the user where to click when he wants to move the
object.]]
function objects.getMovePos(self)
  local objType = self.objType
  if (objects[objType] and objects[objType].getMovePos) then
    return objects[objType].getMovePos(self)
  elseif (self.isContainer and objects.Container[objType] and objects.Container[objType].getMovePos) then
    return objects.Container[objType].getMovePos(self)
  else
    return self.absoluteX, self.absoluteY
  end
end

--[[ Returns the position of the pixel which shows
the user where to click when he wants to scale the
object.]]
function objects.getScalePos(self)
  if not self.canScale then
    error("Tried to get scale pos of an unscalable object!")
  end
  
  local objType = self.objType
  if (objects[objType] and objects[objType].getScalePos) then
    return objects[objType].getScalePos(self)
  elseif (self.isContainer and objects.Container[objType].getScalePos) then
    objects.Container[objType].getScalePos(self)
  else
    return self.absoluteX + self.width - 1, self.absoluteY + self.height - 1
  end
end

-- Returns the left, top, right and bottom coordinates of the object.
function objects.getDimensions(self)
  local objType = self.objType
  if (objects[objType] and objects[objType].getDimensions) then
    return objects[objType].getDimensions(self)
  elseif (self.isContainer and objects.Container[objType] and objects.Container[objType].getDimensions) then
    return objects.Container[objType].getDimensions(self)
  else
    local left, top, right, bottom
    left, top = self.x, self.y
    right = left + self.width - 1
    bottom = top + self.height - 1
    return left, top, right, bottom
  end
end

-- >> Unknown
objects.Unknown = {}
objects.Unknown.new = function(objType)
  objType = objType and " \"" .. objType .. "\"" or ""
  error("Tried to create new object with unknown object ID" .. objType .. "!")
end

objects.Unknown.get = function(self)
  error("Tried to get the buffer of and unknown object!")
end

objects.Unknown.draw = function(self)
  assert(self, "Draw function got called with nil parameter!")
  
  local x = self.x
  local y = self.y
  
  if (x and y) then
    out.setCursorPos(x, y)
    out.write("?")
  else
    error("Tried to draw invalid object!")
  end
end

-- >> Button
objects.Button = {}
objects.Button.new = function(self, maxWidth, maxHeight)
  self.width = (maxWidth < size.Button.width) and maxWidth or size.Button.width
  self.height = (maxHeight < size.Button.height) and maxHeight or size.Button.height
  self.widthPercent = maxX / self.width
  self.heightPercent = maxY / self.height
  self.text = "Button"
  self.funcType = ""
  self.param = ""
  self.canScale = true
  self.canClick = true
end

objects.Button.get = function(self, buttonColor)
  local width = self.width
  local height = self.height
  local path = self.path
  local text = self.text
  local color = buttonColor or objectColors.Button.default
  
  local buffer = Buffer:new()
  local textCol = math.floor((width - string.len(text)) / 2) + 1
  local textRow = math.ceil(height / 2)
  buffer:init(width, height, path, color, objectColors.Button.text)
  buffer:addText(textCol, textRow, text)
  
  return buffer
end

-- Returns: "button_clicked" event, objID
objects.Button.click = function(self, x, y)
  assert(self)
  
  local actionType = self.funcType
  local param = self.param
  
  if (actionType == "switch") then
    drawWindow(param)
    return nil, nil
  elseif (actionType == "function") then
    if changeButtonColor then
      objects.draw(self, objectColors.Button.active)
    end
    
    if userFunctions[param] then
      userFunctions[param]()
    elseif editorFunctions[param] then
      editorFunctions[param]()
    end
    
    if changeButtonColor then
      objects.draw(self, objectColors.Button.default)
    else
      changeButtonColor = true
    end
    
    return "button_clicked", {self.objID}
  end
end

-- >> Text
objects.Text = {}
objects.Text.new = function(self)
  self.text = "Text"
  self.width = #self.text
  self.height = 1
end

objects.Text.get = function(self)
  local width = #self.text
  local buffer = Buffer:new()
  buffer:init(width, 1, self.path)
  buffer:addText(1, 1, self.text)
  
  return buffer
end

objects.Text.draw = function(self)
  local x = self.x
  local y = self.y
  local text = self.text
  out.setCursorPos(x, y)
  out.write(text)
end

objects.Text.getDimensions = function(self)
  local left, top, right, bottom = self.x, self.y, 1, self.y
  right = left + string.len(self.text) - 1
  return left, top, right, bottom
end

-- >> Variable
objects.Variable = {}
objects.Variable.new = function(self)
  self.width = 1
  self.height = 1
end

objects.Variable.get = function(self, value)
  local buffer = Buffer:new()
  
  if value then
    buffer:init(string.len(value), 1, self.path)
    buffer:addText(1, 1, value)
  else
    buffer:init(1, 1, self.path)
  end
  
  return buffer
end

-- >> Progress Bar
objects.ProgressBar = {}
objects.ProgressBar.new = function(self, maxWidth)
  self.length = (maxWidth < size.ProgressBar.length) and maxWidth or size.ProgressBar.length
  self.lengthPercent = maxX / self.length
  self.width = self.length
  self.height = 1
  self.direction = "right"
  self.objID = "newProgressBar"
  self.canScale = true
end

objects.ProgressBar.get = function(self, value)
  local length = self.length
  local direction = (isValidDirection(self.direction)) and self.direction or "right"
  local orientation = getOrientation(direction) or error("Direction " .. direction .. " is invalid!")
  value = value or progressBarValues[self.objID]
  
  if (orientation == "horizontal") then
    width, height = length, 1
  else
    width, height = 1, length
  end
  
  local buffer = Buffer:new()
  buffer:init(width, height, self.path, objectColors.ProgressBar.background)
  
  if value then
    local color
    if (value < 33) then
      color = objectColors.ProgressBar.low
    elseif (value > 66) then
      color = objectColors.ProgressBar.high
    else
      color = objectColors.ProgressBar.medium
    end
    
    local filled = math.floor((length / 100) * value)
    local valueBuffer = objects.Line.get(getOrientation(direction), filled, color)
    local addX, addY = 1, 1
    
    if (direction == "left") then
      addX = width - filled
    elseif (direction == "up") then
      addY = height - filled
    end
    
    buffer:addBuffer(addX, addY, valueBuffer)
  end
  
  return buffer
end

objects.ProgressBar.getMovePos = function(self)
  local dir = self.direction
  local length = self.length
  local x, y = self.absoluteX, self.absoluteY
  
  if (dir == "left") then
    return x + length - 1, y
  elseif (dir == "up") then
    return x, y + length - 1
  else
    return x, y
  end
end

objects.ProgressBar.getScalePos = function(self)
  local dir = self.direction
  local length = self.length
  local x, y = self.absoluteX, self.absoluteY
  
  if (dir == "right") then
    return x + length - 1, y
  elseif (dir == "down") then
    return x, y + length - 1
  else
    return x, y
  end
end
-- Move and scale pos is wrong when the progress bar goes up.
objects.ProgressBar.scale = function(self, x, y)
  local moveX, moveY = objects.getMovePos(self)
  local length
  local newX, newY
  local direction
  local width, height
  
  if (x < moveX and y == moveY) then -- Clicked left of the progressBar.
    length = moveX - x + 1
    newX, newY = x, y
    direction = "left"
    width, height = length, 1
  elseif (x == moveX and y < moveY) then -- Clicked above the progressBar.
    length = moveY - y + 1
    newX, newY = x, y
    direction = "up"
    width, height = 1, length
  elseif (x > moveX and y == moveY) then -- Clicked right of the progressBar.
    length = x - moveX + 1
    direction = "right"
    newX, newY = moveX, moveY
    width, height = length, 1
  elseif (x == moveX and y > moveY) then -- Clicked below the progressBar.
    length = y - moveY + 1
    direction = "down"
    newX, newY = moveX, moveY
    width, height = 1, length
  else
    return
  end
  
  if (length > 2) then
    self.absoluteX, self.absolutey = newX, newY
    self.x, self.y = Path.getRelativePos(self.path, newX, newY)
    self.direction = direction
    self.width, self.height = width, height
    self.length = length
    self.lengthPercent = length / maxX
  end
end

-- >> Input
objects.Input = {}
objects.Input.new = function(self)
  self.message = "Enter something."
  self.isPassword = false
  self.width = 2
  self.height = 1
  self.canClick = true
end

objects.Input.get = function(self)
  local userInput = userInputs[self.objID] or ""
  local width, height = 2 + string.len(userInput), 1
  
  local buffer = Buffer:new()
  buffer:init(width, height, self.path, objectColors.Input.default)
  if userInput ~= "" then
    buffer:addText(userInput)
  end
  
  return buffer
end

-- Returns: "text_changed" event, objID, text
objects.Input.click = function(self)
  local x = self.x
  local y = self.y
  local objID = self.objID
  local message = self.message
  local isPassword = (self.isPassword == nil) and false or self.isPassword
  local maxLength = self.maxLength
  local existingInput = userInputs[objID]
  
  out.setBackgroundColor(objectColors.background)
  out.setCursorPos(x, y)
  if (existingInput ~= nil) then -- Clear the text on the input object.
    out.write(string.rep(" ", string.len(existingInput) + 2))
  else
    out.write("  ")
  end
  userInputs[objID] = nil
  
  out.setCursorPos(x, y)
  if not outIsTerm then
    -- make the input-object yellow
    out.setBackgroundColor(objectColors["Input"].active)
    out.write("  ")
    out.setBackgroundColor(objectColors.background)
  end
  
  if outIsTerm then
    out.setCursorPos(x + 1, y)
  end
  
  local userInput = readUserInput(message, isPassword)
  if (userInput ~= nil) then
    userInputs[objID] = userInput
  end
  
  out.setCursorPos(x, y)
  out.setBackgroundColor(objectColors.Input.default)
  out.setTextColor(objectColors.Input.text)
  
  out.write(" ")
  if (userInput ~= nil and userInput ~= "") then
    if isPassword then
      for i = 1, string.len(userInput) do
        out.write("*")
      end
    else
      out.write(userInput)
    end
  end
  
  out.write(" ")
  out.setBackgroundColor(objectColors.background)
  out.setTextColor(objectColors.text)
  
  -- NOTE: Changed "return ret" to this one:
  return "text_changed", {self.objID, userInput}
end

-- >> List
objects.List = {}
objects.List.new = function(self)
  self.elements = userLists.testList
  self.objID = "testList"
  self.isMultiselect = false
  self.canClick = true
end

objects.List.get = function(self)
  local buffer = Buffer:new()
  local elements = self.elements or { "empty" }
  
  if (type(elements) == "string") then
    elements = { [1]=self.elements }
  end
  
  -- If there's a list which has this list's first element as its key.
  if (#elements == 1 and userLists[elements[1]]) then
    self.elements = userLists[self.elements[1]]
  end
  
  elements = self.elements
  
  local width = getLongestString(elements) + 2
  self.width = width
  local height = #elements
  self.height = height
  local objID = self.objID
  local isMultiselect = self.isMultiselect
  if not selectedItems[objID] then
    selectedItems[objID] = {}
  end
  
  buffer:init(width, height, self.path, objectColors.List.default)
  
  local line = 1
  for key, element in pairs(elements) do
    if (selectedItems[objID][key]) then
      buffer:addBuffer(1, line, objects.Line.get("horizontal", width, objectColors.List.active))
    end
    buffer:addText(2, line, elements[line])
    line = line + 1
  end
  
  return buffer
end

-- Returns: "selection_changed" event, objID, key, true or false
objects.List.click = function(self, x, y)
  local objID = self.objID
  local isMultiselect = self.isMultiselect
  local itemSelected = selectedItems[objID][y]
  
  if (isMultiselect) then
    selectedItems[objID][y] = not itemSelected
  else
    selectedItems[objID] = {}
    selectedItems[objID][y] = true
  end
  
  objects.draw(self)
  
  return "selection_changed", {self.objID, y, selectedItems[objID][y]}
end

objects.List.getFirstSelectedKey = function(self)
  local objID = self.objID
  
  for key, value in pairs(selectedItems[objID]) do
    if (value == true) then
      return key
    end
  end
  
  return nil
end

-- >> File Selector
objects.FileSelector = {}
objects.FileSelector.new = function(self)
  self.width = string.len(text.fileSelector)
  self.height = 1
  self.isMultiselect = false
  self.canClick = true
end

objects.FileSelector.draw = function(self)
  local objectID = objectID
  local x = self.x
  local y = self.y
  local isMultiselect = self.isMultiselect
  
  out.setBackgroundColor(objectColors["FileSelector"].default)
  out.setTextColor(objectColors["FileSelector"].text)
  
  out.setCursorPos(x, y)
  out.write(text.fileSelector)
  
  if (selectedFiles[objectID] ~= nil) then
    out.setBackgroundColor(objectColors.background)
    out.setTextColor(objectColors.text)
    local files = selectedFiles[objectID]
    out.write(" ")
    if (type(files) == "table") then
      local sep = ""
      for _, fileName in pairs(files) do
        term.write(sep .. fileName)
        sep = ", "
      end
    else
      out.write(files)
    end
  end
  
  out.setBackgroundColor(objectColors.background)
  out.setTextColor(objectColors.text)
end

objects.FileSelector.click = function(self, x, y)
error("Not yet implemented")
-- TODO
  local finished = false
  local path = "/"
  local list = {}
  
  while not finished do
    clearScreen()
    out.setCursorPos(2, 1)
    out.write("Path: " .. path)
    
    list = getFileList(path)
    
    out.setTextColor(objectColors.FileSelector.text)
  end
end

-- >>> Containers

objects.Container = {}

objects.Container.getNextFreeKey = function(self)
  local nextKey = 1
  
  while self.children[nextKey] ~= nil do
    nextKey = nextKey + 1
  end
  
  return nextKey
end

-- Returns the area of the container which stores
-- its children.
objects.Container.getContentArea = function(self)
  assert(self)
  local objType = self.objType
  
  if (objects.Container[objType].getContentArea) then
    return objects.Container[objType].getContentArea(self)
  else
    local left = self.x + 1
    local top = self.y + 1
    local right = self.x + self.width - 2
    local bottom = self.y + self.height - 2
    return left, top, right, bottom
  end
end

-- Determines whether the container itself or its
-- content area is at the given position.
objects.Container.contentAreaClicked = function(self, x, y)
  local left, top, right, bottom = objects.Container.getContentArea(self)    
  
  return (x >= left and x <= right and y >= top and y <= bottom)
end

-- Draws the buffer and trims it before if
-- necessary.
objects.Container.drawBuffer = function(self, buffer, path, x, y, absoluteX, absoluteY, nestLevel)
  if (self.objType ~= "Window") then
    local containerLeft, containerTop, containerRight, containerBottom = 1, 1, self.width - 1, self.height - 1
    local objLeft, objTop, objRight, objBottom = x, y, x + buffer.width - 1, y + buffer.height - 1
    if (objLeft > self.width or
        objTop > self.height or
        objRight < 0 or
        objBottom < 0) then
      return
    elseif (objLeft < containerLeft or objTop < containerTop or objRight > containerRight or objBottom > containerBottom) then
      local trimLeft = (containerLeft - objLeft) > 0 and containerLeft - objLeft or 0
      local trimTop = (containerTop - objTop) > 0 and containerTop - objTop or 0
      local trimRight = (objRight - containerRight + 1) > 0 and objRight - containerRight + 1 or 0
      local trimBottom = (objBottom - containerBottom + 1) > 0 and objBottom - containerBottom + 1 or 0
      buffer = buffer:trim(trimLeft, trimTop, trimRight, trimBottom)
      
      if (trimLeft > 0) then
        x = x + trimLeft
        absoluteX = absoluteX + trimLeft
      end
      if (trimTop > 0) then
        y = y + trimTop
        absoluteY = absoluteY + trimTop
      end
    end
  end
  
  if (nestLevel < #path - 1) then
    local container = Path.getContainerAt(path, nestLevel + 1)
    local relX, relY = objects.Container.getRelativePos(container, x, y)
    objects.Container.drawBuffer(container, buffer, path, relX, relY, absoluteX, absoluteY, nestLevel + 1)
  else
    buffer:draw(absoluteX, absoluteY)
  end
end

objects.Container.getRelativePos = function(self, x, y)
  local left, top, right, bottom = objects.Container.getContentArea(self)
  
  retX = x - left + 1
  retY = y - top + 1
  
  return retX, retY
end

objects.Container.getParentsRelativePos = function(self, x, y)
  local left, top, right, bottom = objects.Container.getContentArea(self)
  
  return x + left - 1, y + top - 1
end

objects.Container.new = function(self, maxWidth, maxHeight)
  local defaultWidth, defaultHeight = size.Container.width, size.Container.height
  
  self.isContainer = true
  self.canScale = true
  self.children = {}
  self.width = (maxWidth < defaultWidth) and maxWidth or defaultWidth
  self.height = (maxHeight < defaultHeight) and maxHeight or defaultHeight
  
  if (objects.Container[self.objType].new) then
    objects.Container[objectType].new(object)
  end
end

objects.Container.get = function(self)
  local left, top, right, bottom = objects.Container.getContentArea(self)
  local width, height = right - left + 1, bottom - top + 1
  local buffer = Buffer:new()
  buffer:init(width, height, {})
  
  for objectID, object in pairs(self.children) do
    local objectBuffer = objects.get(object)
    buffer:addBuffer(object.x, object.y, objectBuffer)
  end
  
  return objects.Container[self.objType].get(self, buffer)
end

objects.Container.move = function(self, addX, addY)
  self.absoluteX = self.absoluteX + addX
  self.absoluteY = self.absoluteY + addY
  
  for _, child in pairs(self.children) do
    if child.isContainer then
      objects.Container.move(child, addX, addY)
    else
      child.absoluteX = child.absoluteX + addX
      child.absoluteY = child.absoluteY + addY
    end
  end
end

-- >> Window

objects.Container.Window = {}
objects.Container.Window.new = function(windowName)
  local object = {}
  object.objType = "Window"
  object.parent = "mainWindow"
  object.children = {}
  object.width, object.height = maxX, maxY
  
  return object
end

objects.Container.Window.create = function(windowName)
  local object = objects.Container.Window.new(windowName)
  windows.children[windowName] = object
end

objects.Container.Window.get = function(self, contentBuffer)
  return contentBuffer
end

objects.Container.Window.getContentArea = function(self)
  return 1, 1, maxX, maxY
end

-- >> Panel

objects.Container.Panel = {}
objects.Container.Panel.get = function(self, contentBuffer)
  local buffer = Buffer:new()
  buffer:init(self.width, self.height, self.path, objectColors.Container.Panel.border)
  buffer:addBuffer(2, 2, contentBuffer)
  
  return buffer
end

-- >>> Objects that can't be added by the user.

-- >> Line

objects.Line = {}
objects.Line.get = function(orientation, length, color)
  if (orientation ~= "horizontal" and orientation ~= "vertical") then
    orientation = getOrientation(orientation) or error("Orientation " .. orientation .. " is invalid!")
  end
  
  assert(length)
  assert(color)
  
  local width, height = (orientation == "horizontal") and length, 1 or 1, length
  local buffer = Buffer:new()
  buffer:init(width, height, nil, color)
  
  return buffer
end

-- >> Editor objects
objects.Selector = {}
objects.Selector.draw = function(x, y, elements)
  width = getLongestString(elements) + 2
  height = #elements + 2 -- Elements + up and down
  elementCount = #elements
  displayCount = elementCount
  
  enoughXSpace = true
  -- determine where the selector should actually be displayed
  if (width > maxX) then -- Not enough monitors horizontally?
    x = 1
    enoughXSpace = false
  elseif (maxX - x < width) then -- Not enough space to the right.
    if (x >= width) then -- Let's see if there is space to the left.
      x = x - width
    else -- No space? Check where you've got more space.
      if (maxX / 2) > x then -- More space to the left.
        x = maxX - width + 1
        enoughXSpace = false
      else -- More space to the right
        x = 1
        enoughXSpace = false
      end
    end
  else -- Enough space to the right.
    x = x + 1
  end
  
  if (height > maxY - y) then -- Not enough space from y to bottom.
    if ((maxY / 2) > y) then -- More space below y.
      if enoughXSpace then
        if (maxY < height) then -- Too big for the whole screen.
          y = 1
          displayCount = maxY - 2
        else -- Enough space next to x and not too high.
          y = maxY - height
        end
      else -- Can't display it next to the selected point.
        y = y + 1
        displayCount = maxY - y - 1
      end
    else -- More space above y.
      if enoughXSpace then
        if (y < height) then -- Not enough space from top to y.
          if (maxY < height) then -- Too big for the whole screen.
            y = 1
            displayCount = maxY - 2
          else -- Enough space next to x and not too high.
            y = 1
          end
        else -- Enough space from top to y.
          y = y - height + 1
        end
      else
        if (y < height) then -- Not enough space from top to y.
          if (maxY < height) then -- Too big for the whole screen.
            y = 1
            displayCount = maxY - 2
          else -- Not enough space next to x but not too high.
            y = 1
            displayCount = y - 4
          end
        else -- Enough space from top to y.
          y = y - height
        end
      end
    end
  end
  
  out.setBackgroundColor(objectColors.background)
  
  -- Read the user input.
  scroll = 1
  right = x + width - 1
  bottom = y + displayCount + 1
  
  finished = false
  while not finished do
    -- Display the actual selector.
    drawBox(x, y, width, height, objectColors.List.default)
    
    out.setBackgroundColor(objectColors["List"].default)
    middle = math.floor(width / 2)
    out.setCursorPos(x + middle, y)
    out.write("^")
    out.setCursorPos(x + middle, bottom)
    out.write("V")
    
    for i = 1, displayCount do
      out.setCursorPos(x, y + i)
      out.write(" " .. elements[i + scroll - 1] .. " ")
    end
    out.setBackgroundColor(objectColors.background)
    
    touchX, touchY, mouseButton = getCursorInput()
    
    if (touchX < x or touchX > right or touchY < y or touchY > bottom) then
      selectedItem = nil
      result = false
      finished = true
    else -- User touched the selector.
      if (touchY == y) then -- up
        if (scroll > 1) then -- Check if it makes sense to scroll up.
          scroll = scroll - 1
        end
      elseif (touchY == bottom) then -- down
        if (displayCount < elementCount) then
          if (scroll <= elementCount - displayCount) then
            scroll = scroll + 1
          end
        end
      else
        selectedItem = elements[touchY - y + scroll - 1]
        result = true
        finished = true
      end
    end
  end
  
  drawWindow(currentWindow)
  return result
end

-- >> API Functions

-- API function: Sets the value of all variables
-- with the given ID.
function setVariableValue(variableID, newVar)
  variableValues[variableID] = newVar
end

-- API function: Sets the value of all progressBars
-- with the given ID.
function setProgressBarValue(objID, newVar)
  progressBarValues[objID] = newVar
end

-- >> User Input Functions

-- Gets any input of the user
-- (not from the environment)
function getAnyInput()
  local finished = false
  local event = {}
  
  while not finished do
    finished = true
    os.sleep(0)
    
    input = {os.pullEvent()}
    event.eventType = input[1]
    
    if (event.eventType == "monitor_touch" and not outIsTerm) then
      event.eventType = "mouse"
      event.x = input[3]
      event.y = input[4]
      event.mouseButton = 1
    elseif (event.eventType == "mouse_click" and outIsTerm) then
      event.eventType = "mouse"
      event.x = input[3]
      event.y = input[4]
      event.mouseButton = input[2]
    elseif (event.eventType == "key") then
      event.key = input[2]
    else
      finished = false
    end
  end
  
  return event
end

-- Returns where the user clicked and which button
-- he pressed (always 1 if it's a monitor).
function getCursorInput()
  local finished = false
  
  while not finished do
    event, param, x, y = os.pullEvent()
    
    if (event == "monitor_touch" and not outIsTerm) then
      mouseButton = 1
      finished = true
    elseif (event == "mouse_click" and outIsTerm) then
      mouseButton = param
      finished = true
    end
  end
  
  return x, y, mouseButton
end

-- Waits until any key gets pressed.
function getKeyInput()
  os.pullEvent("key")
end

function readUserInput(message, isPassword)
  if not outIsTerm then
    print(message)
  end
    
  if isPassword  then
    ret = read("*")
  else
    ret = read()
  end
  
  return ret
end

-- >> Display Functions

-- Has to be used instead of paintutils.drawpixel
function drawPixel(x, y, color)
  out.setCursorPos(x, y)
  out.setBackgroundColor(color)
  out.write(" ")
end

function drawBox(x, y, width, height, color)
  out.setBackgroundColor(color)
  
  for row = 1, height do
    out.setCursorPos(x, y + row - 1)
    out.write(string.rep(" ", width))
  end
end

-- Displays the text with red background colour.
function drawSimpleButton(x, y, text)
  out.setCursorPos(x, y)
  out.setBackgroundColor(objectColors.Button.default)
  out.write(text)
  out.setBackgroundColor(objectColors.background)
end

-- Displays the default buttons.
function drawDefaultButtons()
  local window = getCurrentWindow()
  local button
  
  if (window.showRefreshButton) then
    button = defaultButtons.refresh
    drawSimpleButton(button.left, button.top, button.text) -- Refresh
  end
  
  if (window.showBackButton and currentWindow ~= "mainWindow") then
    button = defaultButtons.back
    drawSimpleButton(button.left, button.top, button.text) -- Back
  end
  
  button = defaultButtons.quit
  drawSimpleButton(button.left, button.top, button.text) -- Quit
  
  button = defaultButtons.options
  if (button.required()) then
    drawSimpleButton(button.left, button.top, button.text) -- Options
  end
end

-- Loads the values of all variables and progressBars
-- of the current window.
function loadObjects()
  local window = getCurrentWindow()
  for objectID, object in pairs(window.children) do
    local objectType = object.objType
    
    if (objectType == "Variable" or objectType == "ProgressBar") then
      local x = object.absoluteX
      local y = object.absoluteY
      local value = nil
      
      if (objectType == "Variable") then
        value = getVariableValue(object)
      elseif (objectType == "ProgressBar") then
        value = getProgressBarValue(object)
      end
      
      objects.draw(object, value)
    end
  end
end

-- Displays all objects of the window with the
-- ID windowID on the screen and changes the
-- variable "currentWindow".
function drawWindow(windowID)
  clearScreen()
  
  if windowID then
    currentWindow = windowID
  else
    windowID = currentWindow
  end
  
  local windowObject = getCurrentWindow()
  
  windowBuffer = objects.Container.get(windowObject)
  windowBuffer:draw()
  
  if autoLoadObjects then
    loadObjects()
  end
  
  text.refresh = editMode and "Options" or "Refresh"
  drawDefaultButtons()
end

-- >> Input Processing

function pullEvent(requestedEvent)
  if not eventTypeExists(requestedEvent) then
    clearScreen()
    print("Event type " .. tostring(requestedEvent) .. " is invalid!")
    print()
    print("Available event types:")
    
    for _, event in pairs(eventTypes) do
      print("  " .. event)
    end
    
    error()
  end
  
  local finished = false
  local event, params
  
  while not finished do
    event, params = getInput()
    
    if event then
      if (requestedEvent ~= nil) then
        if (requestedEvent == event or event == "quit") then
          finished = true
        end
      else
        finished = true
      end
    end
  end
  
  return event, unpack(params)
end

function getInput()
  local finished = false
  local event, params
  local x, y, mouseButton = getCursorInput()

  if (defaultButtonPressed("quit", x, y)) then
    quit = true
  elseif (defaultButtonPressed("refresh", x, y)) then
    drawWindow()
    finished = true
  elseif (defaultButtonPressed("back", x, y)) then
    if (windows.children[currentWindow].parent ~= nil) then
      drawWindow(windows.children[currentWindow].parent)
      finished = true
    else
      drawWindow("mainWindow")
      finished = true
    end
  end
  
  if finished then
    return nil
  elseif quit then
    return "quit", { "Graffiti" } -- Used for the API
  end
  
  local param
  local path = windowBuffer.bufferTable[x][y].path
  if path and #path > 0 then
    local object = Path.getObject(path)
    local clickX, clickY = Path.getRelativePos(path, x, y)
    clickX, clickY = x - object.x + 1, y - object.y + 1
    event, params = objects.click(object, clickX, clickY)
  end
  
  return event, params
end

-- Returns a table with most informations that an AddOn would need.
function getSystemInfo()
  systemInfo = {}
  systemInfo.maxX = maxX
  systemInfo.maxY = maxY
  systemInfo.selectedItems = selectedItems
  systemInfo.userInputs = userInputs
  
  return systemInfo
end

function callAddOn(object, callType)
  addOnName = object.addOnName
  objectID = object.objID
  x = object.x
  y = object.y
  width = object.width
  height = object.height
  addOnPath = fs.combine(shell.dir(), addOnName .. addOnExtension)
  
  systemInfo = getSystemInfo()
  systemInfo.x = x
  systemInfo.y = y
  systemInfo.width = width
  systemInfo.height = height
  
  if changeButtonColor then
      objects["Button"].draw(object, objectColors["Button"].active)
  end
  
  shell.run(addOnPath, callType, objectID, textutils.serialize(systemInfo))
  
  if changeButtonColor then
    objects["Button"].draw(button, objectColors["Button"].default)
  else
    changeButtonColor = true
  end
end

-- Shows the message on the computer for debugging. Probably my most-used function.
function debugMessage(message)
  if outIsTerm then
    error("Can't display a debug message on a computer!")
  end
  
  print(message)
end

-- Calls the "getInput" function until the user presses the quit-button.
function main()
  drawWindow("mainWindow")
  
  while not quit do
    getInput()
  end
end

-- Saves the content of the windows-table into the save file
function saveWindows()
  saveString = textutils.serialize(windows.children)
  file = fs.open(saveFileName, "w")
  file.write(saveString)
  file.close()
end

-- Loads the save file and puts the content into the windows-table
function loadWindows()
  if not fs.exists(saveFileName) then
    return
  end
  
  file = fs.open(saveFileName, "r")
  loadString = file.readAll()
  if (loadString ~= nil and loadString ~= "") then
    windows.children = textutils.unserialize(loadString)
  end
  file.close()
end

function splitAt(self, delimiter)
  delimiterPos = string.find(self, delimiter)
  left = string.sub(self, 1, delimiterPos - 1)
  right = string.sub(self, delimiterPos + #delimiter)
  
  return left, right
end

-- >>> Editor

function generateWindowList()
  ret = { "mainWindow" }
  for key, value in pairs(windows.children) do
    if (key ~= "mainWindow") then
      table.insert(ret, key)
    end
  end
  
  return ret
end

editorWindows = {
  children = {
    mainWindow = {
      objType = "Window",
      children = {
        [1] = { objType="Text", x=2, y=1, text="Mode:", path={1} };
        [2] = { objType="List", x=2, y=3, elements=editActions, objID="editActionList", isMultiselect=false, canClick=true, path={2} };
        [3] = { objType="Button", x=2, y=7, width=13, height=3, text="Last Window", funcType="function", param="editLastWindow", canClick=true, canScale=true, path={3} };
        [4] = { objType="Button", x=17, y=7, width=13, height=3, text="Window List", funcType="function", param="loadWindowList", canClick=true, canScale=true, path={4} };
      };
    };
    
    windowListWindow = {
      objType = "Window",
      children = {
        [1] = { objType="List", x=2, y=2, elements=windowList, objID="windowList", isMultiselect=false, canClick=true, path={1} };
        [2] = { objType="Button", x=2, y=maxY-6, width=12, height=1, text="Set parent", funcType="function", param="setParent", canClick=true, canScale=true, path={2} };
        [3] = { objType="Button", x=2, y=maxY-4, width=8, height=1, text="New", funcType="function", param="newWindow", canClick=true, canScale=true, path={3} };
        [4] = { objType="Button", x=2, y=maxY-3, width=8, height=1, text="Edit", funcType="function", param="editWindow", canClick=true, canScale=true, path={4} };
        [5] = { objType="Button", x=2, y=maxY-2, width=8, height=1, text="Delete", funcType="function", param="deleteWindow", canClick=true, canScale=true, path={5} };
      };
    };
  };
}

-- Used to give a List-object an array of all windows
function editorFunctions.loadWindowList()
  windowList = generateWindowList()
  editorWindows.children.windowListWindow.children[1].elements = windowList
  changeButtonColor = false
  drawWindow("windowListWindow")
end

function editorFunctions.editLastWindow()
  if (lastWindow == nil) then
    lastWindow = "mainWindow"
  end
  
  showEditorOptions = false
  drawWindow(lastWindow)
  changeButtonColor = false
end

-- Let's the user define the parent-attribute of the current window.
function editorFunctions.setParent()
  if (selectedItems.windowList == nil) then
    return
  end
  
  local list = editorWindows.children.windowListWindow.children[1]
  local selected = objects.List.getFirstSelectedKey(list)
  
  for i = 1, list.height do
    if (i ~= selected) then
      if (windowList[i] == windows.children[windowList[selected]].parent) then
        drawPixel(1, i + 1, colors.yellow)
      else
        drawPixel(1, i + 1, colors.lime)
      end
    end
  end
  
  local x, y, mouseButton = getCursorInput()
  local selectedParent = y - list.y + 1
  
  if (selectedParent >= 1 and selectedParent <= list.height) then -- Clicked inside the list.
    if (selectedParent ~= selected) then -- Selected parentWindow is not selected window.
      windows.children[windowList[selected]].parent = windowList[selectedParent]
    end
  end
  
  for i = 1, list.height do
    drawPixel(1, i + list.y - 1, colors.black)
  end
end

-- Creates a new window. The user has to enter the window name in the computer.
function editorFunctions.newWindow()
  clearScreen()
  
  if not outIsTerm then
    out.setCursorPos(2, 2)
    out.write("Enter a window-name.")
  end
  
  out.setCursorPos(1, 1)
  
  message = "Pleas enter the name of the new window or nothing to cancel."
  userInput = readUserInput(message, false)
  
  while (userInput ~= nil and userInput ~= "" and windows.children[userInput] ~= nil) do
    message = "There is already a window with that name!"
    userInput = readUserInput(message, false)
  end
  
  if (userInput ~= nil and userInput ~= "") then
    objects.Container.Window.create(userInput)
    showEditorOptions = false
    drawWindow(userInput)
    lastWindow = userInput
    changeButtonColor = false
  end
end

-- Edits the window that has been selected in the "windowList"-list.
function editorFunctions.editWindow()
  if selectedItems.windowList then
    local list = editorWindows.children.windowListWindow.children[1]
    local key = objects.List.getFirstSelectedKey(list)
    key = key or 1
    
    showEditorOptions = false
    lastWindow = windowList[key]
    drawWindow(lastWindow)
    changeButtonColor = false
  end
end

-- Deletes the window that has been selected in the "windowList"-list.
function editorFunctions.deleteWindow()
  local list = editorWindows.children.windowListWindow.children[1]
  local key = objects.List.getFirstSelectedKey(list)
  
  if (key and windowList[key] ~= "mainWindow") then
    windows.children[windowList[key]] = nil
    showEditorOptions = true
    editorFunctions.loadWindowList()
  end
end

-- Shows lines marking the top left part of an
-- object as well as well as pixels displaying
-- the alignment of an object.
function drawAlignmentLines(object, left, top, right, bottom)
  local color = objectColors.Editor.marker
  local moveX, moveY = objects.getMovePos(object)
  
  -- Draw the lines.
  objects["Line"].draw(left - 1, moveY, "left", left - 2, color) -- left
  objects["Line"].draw(moveX, top -1, "up", top - 2, color) -- up
  objects["Line"].draw(right + 1, moveY, "right", maxX - (right + 1), color) -- right
  objects["Line"].draw(moveX, bottom + 1, "down", maxY - (bottom + 1), color) -- down
  
  -- Display the alignment-pixels.
  horizontalAlignment = object.horizontalAlignment
  verticalAlignment = object.verticalAlignment
  
  if (horizontalAlignment == "left" or horizontalAlignment == "stretch") then -- left
    drawPixel(1, moveY, objectColors["Editor"].alignmentTrue)
  else
    drawPixel(1, moveY, objectColors["Editor"].alignmentFalse)
  end
  
  if (horizontalAlignment == "right" or horizontalAlignment == "stretch") then -- right
    drawPixel(maxX, moveY, objectColors["Editor"].alignmentTrue)
  else
    drawPixel(maxX, moveY, objectColors["Editor"].alignmentFalse)
  end
  
  if (verticalAlignment == "top" or verticalAlignment == "stretch") then -- top
    drawPixel(moveX, 1, objectColors["Editor"].alignmentTrue)
  else
    drawPixel(moveX, 1, objectColors["Editor"].alignmentFalse)
  end
  
  if (verticalAlignment == "bottom" or verticalAlignment == "stretch") then -- bottom
    drawPixel(moveX, maxY, objectColors["Editor"].alignmentTrue)
  else
    drawPixel(moveX, maxY, objectColors["Editor"].alignmentFalse)
  end
  
  out.setBackgroundColor(objectColors.background)
end

-- Returns the values of horizontalAlignment and
-- verticalAlignment depending which sides are set
-- to true.
function getAlignment(left, top, right, bottom)
  local retHorizontal, retVertical = "left", "top"
  
  if right then
    if left then
      retHorizontal = "stretch"
    else
      retHorizontal = "right"
    end
  else
    retHorizontal = "left"
  end
  
  if bottom then
    if top then
      retVertical = "stretch"
    else
      retVertical = "bottom"
    end
  else
    retVertical = "top"
  end
  
  return retHorizontal, retVertical
end

-- Let's the user delete an object or change its attributes depending on the current edit-mode.
function editObject(object)
  assert(object)
  
  local objType = object.objType
  local left, top, right, bottom = objects.getDimensions(object)
  local actionsList = editorWindows.children.mainWindow.children[2]
  local action = editActions[objects.List.getFirstSelectedKey(actionsList)]
  
  if (action == "Delete") then
    objects.remove(object)
  elseif (action == "Attributes") then
    local objAttr = {  }
    local includedAttributes = {
      text = true,
      param = true,
      objID = true,
      message = true,
      elements = true,
      message = true,
      funcType = true,
      isPassword = true,
      isMultiselect = true,
    }
    
    index = 1
    for key, value in pairs(object) do
      if (includedAttributes[key]) then
        table.insert(objAttr, index, key)
        index = index + 1
      end
    end
    
    out.clear()
    
    local yPos = 2
    top = yPos
    for attrKey, attrValue in ipairs(objAttr) do
      out.setCursorPos(2, yPos)
      out.write(attrValue .. ": ")
      out.write(object[attrValue])
      yPos = yPos + 1
    end
    out.setCursorPos(2, yPos + 1)
    out.setBackgroundColor(colors.red)
    out.write(text.done)
    out.setBackgroundColor(objectColors.background)
    
    bottom = yPos - 1
    finished = false
    while not finished do
      local x, y, mouseButton = getCursorInput()
      
      if y >= top and y <= bottom then
        local selectedAttr = objAttr[y - 1]
        if not outIsTerm then
          drawPixel(1, y, colors.yellow)
        end
        
        if (selectedAttr == "param" or
            selectedAttr == "objID" or
            selectedAttr == "message" or
            selectedAttr == "elements" or
            selectedAttr == "message") then
          
          if outIsTerm then
            out.setCursorPos(1, y)
            out.clearLine(y)
            out.setCursorPos(2, y)
            out.write(selectedAttr .. ": ")
          end
          
          userInput = readUserInput("Please enter a value for the " .. selectedAttr .. ".", false)
          if (userInput ~= nil) then
            object[selectedAttr] = userInput
          end
        elseif (selectedAttr == "text") then
          if outIsTerm then
            out.setCursorPos(1, y)
            out.clearLine(y)
            out.setCursorPos(2, y)
            out.write(selectedAttr .. ": ")
          end
          
          userInput = readUserInput("Please enter a value for the " .. selectedAttr .. ".", false)
          if (userInput ~= nil) then
            object[selectedAttr] = userInput
            object.width = #userInput
          end
        elseif (selectedAttr == "funcType") then -- Button attribute
          if (object.funcType == "switch") then
            object[selectedAttr] = "function"
          else
            object[selectedAttr] = "switch"
          end
        elseif (selectedAttr == "isPassword" or selectedAttr == "isMultiselect") then
          if (object[selectedAttr]) then
            object[selectedAttr] = false
          else
            object[selectedAttr] = true
          end
        end
        drawPixel(1, y, colors.black)
        if (not finished and selectedAttr ~= nil) then
          out.setCursorPos(2, y) -- I don't know if that's neccessary...
          for i = 2, maxX do
            out.write(" ")
          end
          out.setCursorPos(2, y)
          out.write(selectedAttr .. ": ")
          out.write(object[selectedAttr])
        end
      elseif (y == yPos + 1 and x >= 2 and x <= 1 + string.len(text.done)) then
        finished = true
      end
    end
  else -- Design mode
    local moveX, moveY = objects.getMovePos(object)
    local scaleX, scaleY
    
    if object.canScale then
      scaleX, scaleY = objects.getScalePos(object)
      drawPixel(scaleX, scaleY, objectColors.Editor.scale)
    end
    
    drawPixel(moveX, moveY, objectColors.Editor.move)
    out.setBackgroundColor(objectColors.background)
    
    local x, y, mouseButton = getCursorInput()
    local relX, relY = Path.getRelativePos(object.path, x, y)
    
    if (relX >= left and relX <= right and relY >= top and relY <= bottom) then -- clicked inside the object
      if (x == moveX and y == moveY) then -- move object
        drawPixel(moveX, moveY, objectColors.Editor.active)
        x, y, mouseButton = getCursorInput()
        addX = x - moveX
        addY = y - moveY
        objects.move(object, addX, addY)
      elseif (object.canScale and x == scaleX and y == scaleY) then -- scale object
        drawPixel(scaleX, scaleY, objectColors.Editor.active)
        out.setBackgroundColor(objectColors.background)
        local x, y, mouseButton = getCursorInput()
        local relX, relY = Path.getRelativePos(object.path, x, y)
        
        objects.scale(object, relX, relY)
      else -- clicked something else inside the object (no idea what I could use this for)
        
      end
    end
  end
  
  out.setBackgroundColor(objectColors.background)
  drawWindow(currentWindow)
end

function markVariables(container)
  assert(container)
  
  for _, object in pairs(container.children) do
    if (object.isContainer) then
      markVariables(object)
    elseif (object.objType == "Variable") then
      drawPixel(object.absoluteX, object.absoluteY, objectColors.Editor.marker)
      out.setBackgroundColor(objectColors.background)
    end
  end
end

function markDefaultButtons()
  local window = getCurrentWindow()
  
  -- refresh button
  local refresh = defaultButtons.refresh
  out.setCursorPos(refresh.left, refresh.top)
  if (window.showRefreshButton) then
    out.setBackgroundColor(objectColors.Button.default)
    out.write(refresh.text)
  else
    out.setBackgroundColor(objectColors.Editor.marker)
    out.write(string.rep(" ", #refresh.text))
  end
  
  -- back button
  if (currentWindow ~= "mainWindow") then
    local back = defaultButtons.back
    out.setCursorPos(back.left, back.top)
    if (window.showBackButton) then
      out.setBackgroundColor(objectColors.Button.default)
      out.write(back.text)
    else
      out.setBackgroundColor(objectColors.Editor.marker)
      out.write(string.rep(" ", #back.text))
    end
  end
  
  out.setBackgroundColor(objectColors.background)
end

function getEditorInput()
  local event
  local x, y, mouseButton
  
  if not showEditorOptions then
    markVariables(getCurrentWindow())
    markDefaultButtons()
    event = getAnyInput()
    
    if (event.eventType == "mouse") then
      x, y, mouseButton = event.x, event.y, event.mouseButton
    end
  end
  
  if (not showEditorOptions and event.eventType == "key") then
    callShortcut(event.key)
  elseif (showEditorOptions or defaultButtonPressed("options", x, y)) then
    showEditorOptions = true
    drawWindow("mainWindow")
    while showEditorOptions and not quit do
      getInput()
    end
  elseif (defaultButtonPressed("quit", x, y)) then
    quit = true
  elseif (defaultButtonPressed("refresh", x, y)) then
    windows.children[currentWindow].showRefreshButton = not windows.children[currentWindow].showRefreshButton
  elseif (defaultButtonPressed("back", x, y)) then
    windows.children[currentWindow].showBackButton = not windows.children[currentWindow].showBackButton
  else
    local container = getCurrentWindow()
    local path = windowBuffer.bufferTable[x][y].path
    
    if (path == nil or #path == 0) then -- No object touched. Draw selector for new object.
      drawPixel(x, y, objectColors.Editor.new)
      if (objects.Selector.draw(x, y, objectTypes)) then -- something has been selected
        objects.create(selectedItem, x, y)
      end
    else
      local object = Path.getObject(path)
      
      if (mouseButton == 1) then
        editObject(object)
      else
        if (objects.Selector.draw(x, y, rightClickActions)) then
          if (selectedItem == "Attributes") then
            lastItem = selectedItems.editActionList
            selectedItems.editActionList = { [2] = true }
            editObject(object)
            selectedItems.editActionList = lastItem
          elseif (selectedItem == "Delete") then
            objects.remove(object)
            drawWindow()
          end
        end
      end
    end
  end
end

function windowEditor()
  editMode = true
  autoLoadObjects = false
  
  showEditorOptions = true
  
  while not quit do
    getEditorInput()
  end
end

-- >>> Screen size adaption

function round(number)
  assert(number)
  comma = number % 1
  if comma < 0.5 then
    ret = math.floor(number)
  else
    ret = math.ceil(number)
  end
  
  return ret
end

function printInfo()
  print()
  print(version)
  print("Author: Encreedem")
  print()
  print("Param(s):")
  print("info - Shows some info about the program... but I guess you know that already.")
  print("edit - Starts the program in edit-mode.")
  print()
  print("Visit the CC-forums or my YouTube channel (LPF1337) for news and help.")
end

function testMethod()
  error("Nothing to test...")
end

-- >>> initialization

-- Tells the user that the monitor or computer
-- doesn't support colors.
function showColorWarning()
  out.clear()
  out.setCursorPos(2, 2)
  out.write("This computer/monitor does not support colors!")
  
  local state = 0
  local move = "I don't know this move!"
  local finished = false
  while not finished and not quit do
    out.setCursorPos(1, 4)
    out.clearLine()
    out.setCursorPos(2, 4)
    
    if (state == 0) then
      move = "<( \" <) <( \" <) <( \" <)"
    elseif (state == 1 or state == 3 or state == 5) then
      move = "  (^\"^)   (^\"^)   (^\"^)"
    elseif (state == 2) then
      move = "  (> \" )> (> \" )> (> \" )>"
    elseif (state == 4) then
      move = " (> \" )><( \" )><( \" <)"
    elseif (state == 6) then
      move = "<( \" <) (>\"<) (> \" )>"
    elseif (state == 7) then
      move = " (v''v) (v''v) (v''v)"
    else
      error("Unable to show you that you need an advanced computer/monitor in a fancy way!")
    end
    
    out.write(move)
    state = (state + 1) % 8
    os.sleep(0.25)
  end
end

-- Checks if the monitor on monitorSide exists and wraps it into "monitor".
function getOutput()
  if (monitor == nil and outIsTerm == false) then
    local monitorFound = false
    for _, side in pairs(sides) do
      if (peripheral.getType(side) == "monitor") then
        monitor = peripheral.wrap(side)
        monitorFound = true
        out = monitor
        outIsTerm = false
      end
    end
    
    if not monitorFound then
      out = term
      outIsTerm = true
    end
  elseif outIsTerm then
    out = term
  else
    out = monitor
  end
end

function init()
  getOutput()
  
  maxX, maxY = out.getSize()
  if (maxX < 16 or maxY < 10) then -- smaller than 2x2
    print("Screen too small! You need at least 2x2 monitors!")
    return false
  elseif not out.isColor() then
    parallel.waitForAny(showColorWarning, getKeyInput)
    out.clear()
    out.setCursorPos(1, 1)
    return false
  end
  
  isAPI = (shell == nil)
  
  initDone = true
  return true
end

function checkArgs()
  doCall = main
  arg = args[1]
  
  if (arg ~= nil) then
    if (arg == "edit") then
      doCall = windowEditor
    elseif (arg == "info") then
      doCall = printInfo
    elseif (arg == "term") then
      outIsTerm = true
    elseif (arg == "test") then
      doCall = testMethod
    end
  end
  
  doCall()
end

if init() then
  loadWindows()
  initDefaultButtons()
  
  if not isAPI then
    loadWindows()
    checkArgs()
    
    if editMode then
      saveWindows()
    end
    
    out.setTextColor(colors.white)
    out.setBackgroundColor(colors.black)
    out.clear()
    out.setCursorPos(1, 1)
  end
else
  error("Graffiti Initialization failed!")
end